<link rel='stylesheet' type='text/css' href='content.css'>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<h1>Scene Properties</h1><p>Usually a property binding is a one-way stream of information, where a View is simply receiving information about a property's changing values.  In a game environment however, there are times where it makes sense to allow Views to actually determine these values as well, for things like a GameObject's position, rotation, etc.  This is where two-way bindings are needed.
</p><p>Scene Properties are two-way bindings, and allows for a View to calculate and set a property on its ViewModel.  This is done in an observable way, and when adding a scene property to a view, 3 specific methods are made available.  For example, adding a Position scene property on a PlayerView will result in these underlying base methods:
</p><br/><h2>Under the hood. Generated Scene Properties</h2><h3>Example PlayerViewResetProperty, CalculateProperty, GetPropertyObservable, Bind.designer.cs</h3><pre><code class='csharp'>// ------------------------------------------------------------------------------
//  &lt;autogenerated&gt;
//      This code was generated by a tool.
//      Mono Runtime Version: 2.0.50727.1433
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  &lt;/autogenerated&gt;
// ------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UniRx;
using UnityEngine;


public class PlayerViewBase : ViewBase {
    
    private System.IDisposable _PositionDisposable;
    
    public virtual void ResetPosition() {
        if (_PositionDisposable != null) {
            _PositionDisposable.Dispose();
        }
        _PositionDisposable = GetPositionObservable().Subscribe(Player.PositionProperty).DisposeWith(this);
    }
    
    protected virtual Vector3 CalculatePosition() {
        return default(Vector3);
    }
    
    protected virtual UniRx.IObservable&lt;Vector3&gt; GetPositionObservable() {
        return this.UpdateAsObservable().Select(p=&gt;CalculatePosition());
    }
    
    public override void Bind() {
        base.Bind();
        // Use this.Player to access the viewmodel.
        // Use this method to subscribe to the view-model.
        // Any designer bindings are created in the base implementation.
        ResetPosition();
    }
}
</code></pre><br/><h3>ResetPosition</h3><p>ResetPosition() is mostly used to initialize the binding, is called in the View's base Bind() method, and typically doesn't need to be overridden and altered.
</p><br/><h3>CalculatePosition</h3><p>CalculatePosition() is the main method you would override on your generated PlayerView, where you would return a Vector3 to give the player's position.
</p><h3>CalculatePosition.cs</h3><script src="https://gist.github.com/micahosborne/2e5c9b6d07b76bcaedb1.js"></script><br/><h3>GetPositionObservable</h3><p>GetPositionObservable() should only be overridden in cases where you have a more convenient or performant method of observing the scene property change, because as you see, this calculation is happening every Update by default.  In this case, we know that ViewBase is already monitoring a TransformChangedObservable (and specifically a PositionChangedObservable as well), so on our PlayerView we would override the GetPositionObservable like this:
</p><h3>GetPositionObservable.cs</h3><script src="https://gist.github.com/micahosborne/3d0e2f8bd65a044e82d6.js"></script><br/>