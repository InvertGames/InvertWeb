<link rel='stylesheet' type='text/css' href='content.css'>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<h1>Controllers</h1><h2>What is it?</h2><p>Controllers dictate the rules of your game and, like ViewModels, they do not inherit from Unity's Monobehaviour.  As they only handle logic, there only ever needs to be one Controller for each type of ViewModel.  For example, when a PlayerViewModel performs the PickupItem command, the PlayerController would simply need to know which PlayerViewModel to execute that command logic on, and the logic remains the same whether there are 4 players or one.
</p><p> A controller is designed to implement the data-driven logic and rules behind an element and could be considered just a "group" of commands for a view-model. The Designer has enough information about an element to implement most of the controller itself In most instances, you only need to apply the logic and rules to each method.  
</p><br/><h2>Best Practices</h2><p>When implementing controllers, think of the element as its own little section of your world, if you want your element to interact or be visible to the entire world, publish events as necessary in your command controller methods.
</p><p>To understand this idea a bit more, take a look at the following diagram.
</p><div class='img-container'><img src='http://i.imgur.com/KbPL9bw.png' /></div><p>So in the diagram above, on the EnemyHit command handler, we publish the command as 'global' event.  This means that services can be your general connection layer that make various elements work together.
</p><h3>But why should I do this?</h3><p>Imagine you create a Player element, if it lives entirely on its own (no dependencies on other controllers, services..etc), you can re-use the element in another game and implement services to connect them together.
</p><br/><br/><h2>The Setup Method</h2><p>The setup method is an implementation of the ISystemService interface, this means that all controllers are ultimately services, they do not derive from monobehaviour.  This means you can easily listen to any kind of event on a controller, as well as publish them.
</p><h3>Important Note</h3><p>You must be careful when listening to events in controllers that use inheritance. For instance, if you have an elementA controller, and a derived elementB controller, and in the setup method you are listening to event 'C', then beth element A and element B will be listening to the same event.  In some cases this may be wanted behaviour, but its important to understand.
</p><br/><br/><h2>The Initialize Method</h2><p>The initialize Method in a controller can be used to initialize an Element's ViewModel (similar to how it might be initialized in the inspector of a View). It is a great place to subscribe to 'Scene Properties'.
</p><h2>Command Handlers</h2><p>Every command that is outlined on an element, in the Element Designer, will have a corresponding method in a controller (assuming the diagram is saved).  
</p><p>There are a few things to notice when looking at the code example below:
</p><p> - The "FPSWeaponController" is derived from "FPSWeaponControllerBase", which is generated by the designer.
</p><p> - All of these methods are overrides, because the base class has implemented an empty "virtual method" for each command.
</p><p> - The reload method has an IEnumerator result type, because is it is marked as a yield command (indicated by the yellow marker).  This can be achieved by right-clicking on a command and checking "Is Yield Command". It is used for simulating a co-routine.
</p><p> - In each method we are simply processing rules by reading and modifying the FPSWeaponViewModel's instance data .
</p><h3>FPSWeaponController.cs</h3><script src="https://gist.github.com/micahosborne/7bba5439faf0b46efa61.js"></script>